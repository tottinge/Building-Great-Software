A Bunch Of Machines
===================


Think About Programming
-----------------------

Before we can start programming, we have to think about programming and 
programs. If you can think about it right, you'll have an advantage over
all the other programmers who learned the basic mechanics but don't really
understand it. footnote:[there are a lot of people who program for a living
but don't really understand what they do. It's very sad.]

Programs are everything that make a computer work, from Windows and Linux and
OS/X (which are basically programs that run other programs), to console games,
to the great Google search engine, to incredible photo-editing programs, word
processors, and online shopping carts.

Programs and hardware have a lot in common. Both of them are things that take
some kind of action such as a mouse movement, and respond by causing something
else to happen. Pressing a button on your video screen may cause it to get
brighter or darker. Typing into an email program may cause it to send a note
across the internet. 

In other words, it's all "machines."  Hardware is a bunch of physical
machines, from resistors to wires to capacitors and springs and buttons.
Software is also a machine, but it's made out of something different. In
this book, you will learn about software parts and how to make machines of
them.

What would you think of a new car made out of duct tape, paperclips, and
chewing gum? It might be pretty cool to actually produce a car that way, but
would you take it out on the highway? Machines can be made well, or can be
made poorly. If we set out to build a machine poorly, it's a hobby or an
experiment.  These are good things! You should be able to make something
well, poorly, or semi-well, and you should enjoy doing it. If the work is
important and you want to be paid or you want people to use the software you
build, you will need to build it well. Don't be surprised that not all
software is built well.

Be warned, you won't be creating any 3D shooters in this book [well, maybe
not], but you will learn the essentials of computer programming. Knowing the
basics will allow you to move to more and more fancy programming machines,
and you may eventually build a 3D shooter, or a spaceship guidance system,
or a web page. 

Also be warned, the topic is sometimes fascinating and exciting, but
sometimes you'll not feel like doing the work. That's pretty normal.
Developing your ability to concentrate and do work until it is exciting
again is a part of learning to program. Also, a programmer has to learn to
stop sometimes and give it a rest. You will learn when to push and when to
rest. 

One Little Machine
------------------
We are going to start with a programming tool called Python. The people who
make python make it because they like it, not because they want to sell it
and get rich.  You can go to http:python.org[the Python web page] and get
python.  It's really easy to install python, it's usually just a download
footnote:[if you use Ubuntu, you can use the software center]. 

********
'Why don't you tell me how to install Python?'


Installation is done differently depending on your operating system, and the
web sites for programming languages already have installation instructions. 
We think those instructions are usually quite good.

Besides, installers change over time. Even if we told you how to do it in
this book, you would have to check the web site to see if it is still done
that way.
********

Once you have python installed, you need to start it. The web page gives you
instructions. You might use a menu and click "python" and "idle", or you
might go to a command line and type "python." Try it both ways, if you like.

Eventually you will get a prompt that looks something like this:
[source,bash]
    Python 2.7.1+ (r271:86832, Apr 11 2011, 18:05:24) 
    [GCC 4.5.2] on linux2
    Type "help", "copyright", "credits" or "license" for more information.
    >>> 

The version numbers and operating system version might be different, don't
let that bother you.

You can now start to play with some little machines. The first is something 
called a 'string,' which is short for 'text string.' A string is some.
letters, spaces, numbers or other text things you can type. In a string,
they are all stuck together inside quotes:

[source,python]
    >>> "hello"
    'hello'

Here we typed +"hello"+ (including the quotes) and python gave us back the 
result, which is a string with the value +'hello'+ (don't worry about the
different quotes for now). I know that doesn't seem like much of a machine,
but it is. You can ask it to do things and it will do them.

[source,python]
    >>> "hello" + ", you"
    'hello, you'
    >>> 

Here we did the same things as last time, but we told the string with
"hello" in it to add a comma and the word 'you'. It did, and returned
a new machine, which is a string with the value "hello, you." 

Python (which is also a machine) responded by printing +'hello you'+.

The plus command above is called an "infix operator" which is a fancy
way of saying that it is a command that sits between the two pieces
of data it works on. Here are a few more "infix operators"

[source,python]
    >>> 1 + 1
    2
    >>> 2*5
    10
    >>> "a" * 4
    'aaaa'

That last one is a bit of a surprise; who would have thought you could
multiply a string? Sure enough, 'a + 4' is 'aaaa.' 

The string is a kind of machine that can obey a large set of commands.
To give it a command, you have to know the name of the command and
type it after a period. Imagine you're talking to the string, and 
you say "string, change yourself to uppercase."  The dot between the
string you're talking to and the command is a lot like the comma in
the above sentence.  

Let's look at a few examples:

[source,python]
    >>> "hello".upper()
    'HELLO'

The string can also convert itself to lower-case:

[source,python]
    >>> "HELLO".lower()
    'hello'

It has some fancy abilities, like capitalizing the first letter of every
word:

[source,python]
    >>> "hello".title()
    'Hello'

We can have it print itself at the right-end of a string, which we call
"right-justified".  Let's right-justify a string in a 40-letter string:

[source,python]
    >>> "hello".rjust(40)
    '                                   hello'

There's no reason to stop there, because we can also left-justify the
string.

[source,python]
    >>> "hello".ljust(40)
    'hello                                   '

We can also have it replace letters with other letters. Let's try replacing
the lower-case 'h' at the beginning with an upper-case H:

[source,python]
    >>> "hello".replace("h","H")
    'Hello'

Of course that looks too easy because it's at the beginning of the word. 
How about we replace all of the lower-case L letters with capital letters?

[source,python]
    >>> "hello".replace("l","L")
    'heLLo'

We can also ask the string questions. Let's ask it how many lower-case 
L letters it has:

[source,python]
    >>> "hello".count('l')
    2
    >>> 

All of the abilities are built-in to the string. It's just the kind of
machine it is. footnote:[Advanced students can find out what a string can
do by typing <code>dir("hello")</code>] Somebody cleverly added these
commands when they designed the string type of machine.

Here is a good place for some terminology. A type of machine is a class. 
Programmers would say that "hello" has the string /class/, or that it is
a thing of /class string/.  

Notice that the string doesn't draw butterflies on the screen, or turn off the
computer or add numbers together. It only does "string stuff." It is important
that each machine we make has commands that work together. It is just like at
your house, where you turn on the television to watch a show, but turn on the
blender to make a milkshake. You use the refrigerator to make things cold, and
the stove to make them hot. It is an important law of machines that they have
only one job to do. 

We call the idea that an idea has only one idea "cohesion." Cohesion implies
all things going in the same direction. That's the right idea. A famous
programmer named Bertrand Meyer once said of a software class that it "Has one
responsibility: it does it all, does it well, and does it only."

Imagine if your real-world items didn't have cohesion in this sense: your
refrigerator would hammer nails, and you would have to start your car to chill
soda pop. Crazy, right?  With cohesion, you always know where to look when you
want a certain job done. If you want to work with some text, you can pretty
much count on the idea that you'll use a string.

Did you notice that we got the value of 2 when we asked how many copies of
letter L were in "hello?"  We know that 2 is a number, but did you know that 2
is also a machine? It is a machine of type "integer."

[source,python]
    >> 2+2
    4
    >> 2*4
    8

These examples don't use the "." to issue commands, and that's almost a shame.
But the + for addition and the * for multiplication are performed by the
integer class. These types of commands are a little different, because they
don't use the dot notation. 

The integers don't actually have methods named "add" and "times", but they do have 
special functions named __add__ and __mul__. You could actually use them, but
python added the + and * as a convenience.
 
It is as if you could write this:

`Will not actually work, we'll show you a way that does soon.`
[source,python]
   >> 2.__add__(2) 
   4
   >> 2.__mul__(4)
   8
   >> 


You don't have to like the names "__mul__" and "__add__" in order to use
them.  The people who made python decided that this is how they would make
their number types. As long as they do what you want, you can tolerate a
little strangeness.

So strings are little machines and numbers are little machines. Already
we could put them together and do very simple jobs. For instance, if we
know the operators for integers, we can use python as a calculator!

Naming Data With Variables
--------------------------

The problem with the code above is that we had to type "hello" every time we
wanted the string that contains the value "hello." What we need is some way
to hold onto the "hello" string and talk about it. Indeed we can. We can
make up a name and assign the value "hello" to that name.  

This is a little confusing, though. The command we use to give a name to a
value is the equals sign (=). All of our lives, we have seen the equal sign
used to state a fact. For instance: 2+2 = 4. We have to rework our brain a
bit to understand that many programming languages do it differently. Some
are more reasonable-seeming than others:

[source,vbscript]
   let x = 3;   <-- BASIC
[source,pascal]
   int x := 3;  <-- Pascal
[source,bash]
   set x=3  <---bash
[source,c]
   int x = 3; <-- C 

In python, it's pretty simple-looking: 

[source,python]
   x = 3

Remember that this little bit of programming is not stating a fact, but 
issuing a command to attach the name "x" to the value of 3. Most of the
time in programming, we don't state facts. We are always telling the 
computer to do something or tell us something.

In python a name is attached to a value, but you can attach it to any
other value you like.

[source,python]
   >> x=3
   >> x="elephant"
   >> x=23.4
   >> x=33*2.33

When we typed 2 or 3 or "hello", python would tell us the value. In 
the example above, it didn't tell us anything. That is because the 
value of 3 was "captured" by the name "x" and there was nothing 
interesting to print on the screen. If you typed "x" on a line by
itself after the last line above, it would say 76.890000000000001
or something very close to it, which is roughly the value of 33
times 2.33. That's close enough to being true that we're not 
worried about it (for now).

We refer to these names for values as "variable" because we can
change what the name points at. It varies, so we call it a variable.

Generally we don't call things X very often, because it doesn't mean
much to us. When we use names later in this book we will use longer
names that mean something to us and which will help people reading
our programs to understand them.

Just for fun we can print a popular myth like this:

[source,python]
   >> print "George Washington has wooden teeth."
   George Washington has wooden teeth.

Print is a special command that tells python (remember python is a machine
too) to show a message on the screen. It isn't very exciting, but it tells
you that you now have new ways to interact with your machine.

Let's step it up to use a single variable:
[source,python]
   >> a = "George Washington has wooden teeth."
   >> print a
   'George Washington has wooden teeth'

We can always check the value of a variable this way. When we get a 
lot of variables, we might sometimes not be sure of one or two of them,
and printing them to the screen is a time-honored way to find out.
Let's try something slightly more advanced:

[source,python]
   >>> a = "George Washington"
   >>> b = "wooden"
   >>> c = "teeth"
   >>> print a  + " has " + b + " " + c + "."
   George Washington has wooden teeth.

Now we see that the print line is a kind of machine that assembles
words into a sentence. That's almost exciting!  

Of course, the variable names are pretty awful. You have to have a 
codebook in your head that says "a stands for George Washington",
"b stands for wooden", and "c stands for teeth."  That's sort of fun
at first, but eventually becomes a real pain in the neck.

Instead, Python allows us to use real names and real words. They have
to start with a letter and contain letters and numbers footnote:[this is mostly true, but not complete]
and maybe the underbar character ("_") to separate words. Names can
be quite long.  Instead of the gibberish names above, we could write
the same thing like this:

[source,python]
   >>> name = "George Washington"
   >>> material = "wooden"
   >>> parts = "teeth"
   >>> print name  + " has " + material + " " + parts + "."
   George Washington has wooden teeth.

Now we can make some changes and print again:
[source,python]
   >>> parts="feet"
   >>> material ="clay"
   >>> print name + " has " + material + " " + parts + "."
   George Washington has clay feet.

Notice how much more obvious it is when we use real names for our data.
That is an important fact that many programmers, even professionals, do
not consider strongly enough.

Writing Functions
-----------------

We would like to stop typing the print line over and over again. Wouldn't
it be cool if we could turn it into a little command with a nice short name?
I think I would like to be able to say something like:
[source,python]
   >> speak_about("George Washington", "wooden", "teeth")
   'George Washington has wooden teeth.'

Then I can give it different values for materials, names, and body parts and
it would do assemble the sentence the same way regardless of what I told it.

We can do that. Python lets us define something called a 'function' which 
will take data and do something with it.
[source,python]
   >>> def speak_of(name, material, parts):
   ...    print name + " has " + material + " " + parts + "."
   ...
   >>>

There are some new things to explain here. The first is the word "def", 
which means we are going to define a new function. 

Next comes the name we want the function to have ("speak_of"), and then
in parenthesis we say what variable names we want to give its data. We
will pass three variables, with the names "name", "material", and "parts."

Next comes a colon. Because we type a colon, python knows we're done 
saying what the function and parameters are, and are ready to give it
the function's instructions. It puts up dots instead of greater-than 
signs to show that it knows there is more to come.

We put a few spaces at the start of each line. In this case, I put three.
As long as we indent the same way, prefixing three spaces, python knows
we're still putting in instructions for "speak_of."

When I'm done with the print line, I get three dots again. I don't have
any more programming to do, so I just hit enter and let the dots go 
away. Python answers with three greater-than signs, just like it usually
does. 

Let's give it a try:
[source,python]
   >>> speak_of("Harry","hairy", "feet")
   Harry has hairy feet.
   >> speak_of("Judy", "golden", "hair")
   Judy has golden hair.
   >> speak_of("Pirates","wooden","legs")
   Pirates has wooden legs

The grammar is awful on that last one, but it works like we told it
to.  Programs don't figure things out, they just follow instructions.
This is why programs often have problem. 

In our case, though, it is not as exciting as we would like. It would be more
fun if there was a way to have it build different sentences out of lists of
different words. It might be more fun yet if it could pick the words randomly. 

In other words, it would be fun to make a machine that spouts
gibberish.

A Gibberish Machine
-------------------


We have lists in python. They are machines that
hold a bunch of values and can give us one or several of them at a time.
It's pretty cool stuff. Python is just full of little machines like
these that we can use to build more interesting machines.

This is going to get wild and wooly, so try to type the examples
and understand them as we go along:

[source,python]
   >>> names = ["tim","jeff","Elvis","Freddie","King James","Nick","You"]

We assign the name "names" to a list of strings. You can tell it is a list because
it is wrapped in square brackets and the items are separated with commas.
That's how python makes lists. Other languages may do it very differently.

We can ask questions about the lists. We can ask the length of the list, for
example: 

[source,python]
   >>> len(names)
   7

Seven looks right. We should be able to get the first name from the list. We
can use a special syntax called a subscript operator to find the first item
in name. We use square brackets for subscripting, just like we did for the list
creation, but we can tell that we are looking into a list because the word before
the first square bracket is not the equal sign but list.

[source,python]
   >>> names[1]
   'jeff'

Uh, oh. That doesn't look right. When we created the list, the first name was 
"tim", so we've done something wrong. If we type "print list", though, we see 
that we still have "tim" in front. Weird, huh? 

The reason is important: computer programmers count from zero, not one. It is
a historical thing but it's pretty normal. So the item at position one is the
item one place from the start. We want the item at position 0.

[source,python]
   >>> names[0]
   'tim'

Okay, that's what we expected. Counting from zero works better.

There is also another way to get data from the array. There is a command called
"pop" which removes one list element and returns it. Let's see if we can grab the first one:

[source,python]
   >>> names = ["tim","jeff","Elvis","Freddie","King James","Nick","You"]
   >>> names.pop()
   'You'

That doesn't seem to have worked. When you get an error in programming, you
might have the urge to just try it again, or throw up your hands in disgust.
Since programming is all about learning and building, a better approach is to
see what actually happened and try to understand it.

In this case, what happened was that we got the last element instead of 
the first. When we look at the python documentation, we see that it is the
right thing for a list to do, we just didn't understand what pop() would 
do. We also will find out that we can tell pop() which item to pull. If
we want the first one, we remember that programmers count from zero and
ask for list item zero:

[source,python]
   >>> names.pop(0)
   'tim'
  
Ah, now that's what we want. Now we have a simple procedure for solving
problems. You always try to figure out what really happened and check the
documentation. Is it doing what it is supposed to do? Did our instructions have
an error in them? After all, a program is a machine so it always does what it
was told to do, but sometimes we don't always tell it to do the right things.

In this case, the author misled you. We said that pop() would get the first 
item, and it does not. Usually you will come to misunderstandings on your own,
and these misunderstandings will come up as errors. Errors are not desirable,
but you have to have them if you are to learn. Programmers have learned a
whole bunch of tricks to keep from misunderstanding code, and to make sure
that they find out quickly when they make a mistake. We'll teach these tricks
as we go along.

The first trick is one you're already doing: read books, try things out, and
concentrate on learning instead of being perfect.

Remember, when we got the last name instead of the first one, the earth did not implode and nobody got hurt. The program just did not work. This is how most 
errors turn out. There have been bugs that hurt people or cost money, but we're 
not going to make those here. 


